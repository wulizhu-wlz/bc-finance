# 知识点梳理总结

## 计算机网络

1. **OSI与TCP/IP各层的结构与功能,都有哪些协议?**
   - 应用层，(表示层，会话层)传输层，网络层，链路层，物理层
   - 应用层指上层的应用进程，通过传输层组织好要传输的报文信息，然后传递到网络层，由网略层找到出口网关，由链路层通过ARP协议拿到MAC地址进行下一跳的工作，物理层将信息发送出去。
2. **TCP 三次握手和四次挥手**
   - SYN-->SYN+ACK-->ACK
   - FIN-->ACK-->FIN-->ACK
   - 三次握手是为了保障通信双方读写都没问题，四次挥手是为了保障通信双方都关闭了资源
3. **http和https**
   - http是基于服务器的80端口进行通信的，客户端可随机指定用于通信的端口，但是有限制，每个网卡最多是65535个端口，http是明文传输，相比于https安全性很差
   - https是http+SSL/TLS，默认使用的443端口进行资源交换，采用了对称加密和非对称加密进行组合将报文加密进行通信，安全性相对较高，在资源交换过程中，通过服务端的证书验证服务端的身份，非对称加密用来协商秘钥，对称加密用来进行传输，保障了安全性
4. **cookie和session**
   - cookie保存在浏览器端，session保存在服务器端，session一般用来存储用户信息，可以通过cookie定位到对应的session从而获取到相关信息
5. **IO,NIO，AIO**
   1. **什么是IO多路复用？**
      - 单线程或者单进程同时检测若干个文件描述符是否可以执行IO操作的能力
   2. **区别**
      - 同步阻塞，同步非阻塞，异步非阻塞
   3. **三种IO多路复用模型**
      - select   主动向kernel轮训所监听的多个fd状态，挨个轮训
      - poll       每次调用kernel都传递一批fd,由kernel返回就绪的fd
      - epoll     epoll_create创建一个epoll实例，epoll_ctl动态添加fd,epoll_wait获取就绪的文件描述符
6. **http和Rpc区别**
   - Rpc没有三次握手可以降低网络开销
   - Rpc框架一般都有注册中心，监控管理
   - 序列化传输的RPC协议占用带宽更少

## 数据库

1. **索引是什么？索引失效？**

   - 索引是B+树的数据结构，分为聚簇索引和非聚簇索引，遵循最左匹配原则，不能用！=，<>，以及范围查询后面的字段索引会失效。
   - 如果采用二叉树的结构，顺序递增会导致二叉树失衡，而红黑树虽然能保证平衡，但是也会导致高度过高，而B-tree是把data数据保存在没个节点上比较浪费空间B+树把所有数据放在叶子节点上，那么非叶子节点就能存储更多的索引，每个B+树的非叶子节点的大小都是16Kb(mysql中的页)，大约能存放1170个(8+6是bigint+指针)索引,所以一个三层的B+树就可以保存两千万的数据
   - **为甚么要主键递增呢？**
     - 如果主键不是递增的话再有新数据插入时会插入到树的中不，这个时候会导致索引非叶子节点的分裂重新构造索引树
   - **不走索引的几种情况**
     - 不等式<>或!=会导致索引失效
     - key为字符串传入的类型为数值类型会失效，字符串要用''
     - 索引字段上做了函数计算
     - 模糊查询%不能放前面
     - 联合索引遵循最左匹配原则

2. **Mysql主从同步，分库分表**

   - 随着业务量的增加，单机的数据库不能满足场景，这里根据读写的比例来决定是否要做成读写分离的方式，如果写请求的过高，那么就需要考虑进行水平分表，因为单机数据库并发有限接连接数受限，宽带受限，IO受限，所以需要更多的机器来给与支持，同时，单标数据过多也会影响性能，一下是一种水平分表的表拆分方案：
     - RANGE:按照数据的区间进行分表
     - HASH取模的方式
     - 按照地理区域分表(根据业务体量)
     - 根据时间进行切分(冷热分离)，把一年一前的数据切出去放到领一张表，
   - **读写分离**
     - 主从同步方式，主节点开启binLog，从节点跟主节点建立连接，主节点会将变更的binlog推送给从节点
   - **分库分表时机**
     - 达到千万级考虑进行分库分表，分表有垂直分表和水平分表，可以采用shardIng JDBC以及使用mycat进行
   - **分库分表后面临的问题**
     - 分布式事务问题，多结果集合并group by order by，跨库join
   - **binlog原理**
     - 每当都新的事件产生，mysql都会写入到binlog中，在配置主从同步时，需要让主节点开启binlog，然后从节点启动一个单独的io线程去读取主节点的binlog文件，将其写入到本地数据库中，也可以根据binlog文件对数据库进行恢复工作

3. **Mysql事务隔离级别**

   - **READ UNCOMMIT 读未提交**：可能产生脏读，不可重复度，幻读
   - **READ COMMIT读已提交** ： 可能产生不可重复读，幻读
   - **Repeatable Read可重复读**：是默认的隔离级别，会产生幻读，在Inner DB中通过采用了行排它锁和MVCC机制解决了幻读的问题，场景事务A和事务B，同事开启查询，在事务A中插入一条数据，事务A可以看到插入的数据，事务B查询不到，此时在事务B中插入相同的数据，会提示主键冲突问题，并且在事务B中查询不到该条数据，解决方案可以通过for updata加上共享锁实现
   -  **Serializable可串行化**：最高级别，不会产生问题

1. **Mysql undoLog 和 redoLog和binLog**
   - **undo log**:每次数据进行更新的时候都会把上一版本的数据生成日志，这些条日志组成的链就是版本链，是通过roll_pointer进行连接的，insert没有roll_pointer，对于读未提交，每次只需要读取最版本数据，对于读已提交和可重复读，通过生成ReadView来控制读取的版本，读已提交会在每次查询的时候生成一个ReadView(记录全局活跃的事务数组)，而可重复度只会在第一次查询时生成ReadView
   - **Redo log**:每次修改数据产生的日志，会持久化到磁盘上，数据库重启时会从Redo log进行恢复,主要用于数据库的崩溃恢复
2. **Mysql组成，一条sql的执行流程**
   1. 接收到客服端发送的查询请求
   2. 检查缓存，如果命中缓存立即返回缓存中的结果
   3. 服务端执行SQL解析，预处理在由优化器生成对应的执行计划
   4. MySQL根据优化器生成的执行计划，再调用存储引擎的API来执行查询
   5. 将结果返回给客户端
3. **如何排查sql执行速度很慢的问题**
   - 数据库是否在刷脏页，此时会影响性能
   - 是否有慢查询占用了数据库的资源(通过慢查询日志可以看到)
   - 数据量过大，考虑索引是否命中，是否需要分库分表，读写分离
   - 并发量过高，导致数据库的带宽不够用
4. **Mysql sql语句执行优先级**
   - 先根据from和join确定要查询哪张表，再根据where约束条件把表中的数据加载到内存，然后根据group by进行分组，分组后根据having条件进行过滤，接着在根据distinct进行去重，在根据order by进行排序，最后根据limit确定要查询多少条数据
5. **InnerDB和MyIsam区别？**
   - 是否支持行级锁，前者支持后者不支持
   - 是否支持外键，前者支持后者不支持
   - 前者支持事务，后者强调的是性能，前者由于对事务的支持，提交，回滚所以有更强的崩溃修复能力
   - 前者支持MVCC机制，后者不支持，并且二者的索引结构分别是聚簇索引和非聚簇索引，聚簇索引由于索引和行数据保存在一行，所以查询效率要好一些9
6. **MVCC机制，行级锁，间隙所**
   - innerDB是通过给索引上的索引项进行加行级锁的，也就是说只有通过索引查询数据才会使用行级锁，否则将会使用表锁，无论是主键索引，唯一索引，普通索引都是可以的。
   - 间隙锁，锁定是某个范围的数据，也可以是不存在的数据
   - mysql在事务中的update,insert都会加锁
   - mvcc机制实现：版本链，ReadView(事务ID)
7. **UNION和UNION ALL区别**
   - 都是对两个查询结果进行合并，前者可以去重后者不可以
   - UNION会对查询的结果进行排序，而后者不会

## 缓存

1. **为什么说redis是单线程的？**

   - redis内部使用文件事件处理器file event handler，这个事件处理器是单线程的，同事监听了多个socket，根据socket上的事件选择对应的处理器去处理
   - 文件事件处理器包含4个部分：
     - 多个socket
     - io多路复用程序
     - 文件事件分派器
     - 事件处理器（连接应答处理器，命令请求处理器，命令回复处理器）

2. **redis是做什么的？**

   - redis是一个内存型数据库，基于内存的访问速度，因此redis多数被用于缓存方向，另外也经常使用redis来做分布式锁，redis支持事务，lua脚本，LRU驱动事件，多种集群方案。

3. **redis和memcached区别**

   - redis中支持更加丰富的数据类型，String,Hash,Set,Zset,List
   - redis可以将数据持久化到磁盘上，而memcached只能保存到内存中
   - redis对集群模式的支持更加友好，原生支持集群模式

4. **redis底层数据类型实现原理**

   - **String：** redis中string类型的数据底层是通过该sds实现的，SDS结构组成如下：

     - free  表示buf中剩余空间的大小

     - len    表示buf中的内容实际占用长度

     - buf    是一个char类型的数组，用于存储实际字符串的内容

       优势：获取字符串的长度复杂度为O(1)，根据free可以防止buf溢出的问题，空间预分配&惰性释放，二进制安全性内容是以二进制的方式存储的不用担心数据格式转换问题

   - **List：** 3.2以后采用的是QuickList，底层结合了zipList和linkedList的优点

     - ZipList: 是由一块连续的存储空间组成，没有前后指针的概念，优点是没有指针节省内存，缺点是插入时涉及到元素的移动操作
     - LinkedList:双向链表
     - QuickList；没个listNode中存储的都是ZipList的指针，每当zipList大小超过8Kb，就是重新创建一个ListNode和ZipList通过指针进行关联起来

   - **Set**：

   - 

5. **redis数据淘汰机制**

   - **内存未耗尽**：

     - 定期删除：每隔100ms会随机抽取一些设置了过期时间的key进行删除，为了防止过度占用cpu只能通过随机抽取的方式
     - 惰性删除：定期删除会导致过期的key没有被删除，在查询这个key的时候会判断下是否过期

   - **内存耗尽，提供了六种淘汰策略**：

     1. **volatile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

     2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

     3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

     4. **allkeys-lru**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）

     5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰

     6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

        4.0版本后增加以下两种：

        1. **volatile-lfu**：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
        2. **allkeys-lfu**：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key

6. **redis持久化机制**

   - **RDB快照机制**:通过定时对内存进行快照来进行持久化，关键点900 1，300 10，60 10000
   - **AOF追加机制**：可以设置每次变更都写入日志(会严重影响性能)，也可以每秒进行追加(推荐)，可以让操作系统去决定何时进行同步
   - **AOF重写**：AOF会定期的或者以手动触发的方式进行文件的重写，在重写文件时，由于写入的量特别大，所以redis会fork出一个子进程进行重写的处理，在重写的过程中服务器端会正常的处理请求，这些请求会被添加到aof_buf的缓冲区中，带重写完成再把缓冲区的内容写入磁盘
   - Redis4.0之后默认是支持两种方案组合的方式，集成了两种方式的有点，可以避免丢失过多的数据，占用更小的空间，唯一不足是可读性较差

7. **Redis事务**

   - 可以通过MULTI,EXEC,WATCH等命令来实现事务功能，事务会将多个命令打包执行，在执行期间不会中断请求去处理其他客户端的请求。

8. r**edis吞吐量，分布式锁实现方案**

   - 单机10w~15w
   - 通过setnx px实现分布式锁
   - Redisson：基于Java封装的redis操作client,提供了锁申请以及锁监控的机制，可以实现RedLock
   - RedLock：集群化锁方案，去redis集群中申请锁，例如五个节点，其中三个节点都拿到了锁，则认为获取锁成功，申请失败需要主动释放所属节点的锁，基于服务器的时间戳机制

9. **缓存穿透和缓存击穿？解决方案**

   - 缓存穿透：请求查询缓存中没有的key，绕过了缓存直接打到数据库，解决方案,可以通过布隆过滤器过滤掉那些不存在的key，也可以通过限流保障数据库的安全，一般情况3000并发就可以让数据库宕机
   - 缓存击穿：当访问的key刚好过期此时有大量的请求打到数据库，解决方案：可以通过锁的方式进行控制，第一个线程拿到锁后访问数据库进行查询，把查询到的结果放入缓存中，后续线程发现有缓存了也就不会再去请求数据库了

10. **缓存雪崩**

    - 当某一时刻发生了大规模的缓存失效的情况可能是缓存服务器宕机，导致所有的请求都打到了数据库上
    - 解决方案：
      - 尽量设置不同的过期时间
      - 使用集群缓存，保证服务的高可用
      - 采用Hystrix做限流&降级，避免Mysql被打死
      - 开启Redis持久化机制，尽快回复集群

11. **如何保证缓存和数据库双写一致性**

    - 非必要不建议这么做，因为这么做的开销很高回避正常情况下多几倍的机器支撑线上的服务
    - 可以通过内存队里去实现，数据更新时先删除缓存，然后发送更新请求到内存队列中，如果是分布式环境，需要做路由确保相同key数据的更新能分配到一个jvm内部队列，后端服务根据内部队列的顺序进行处理，可以保证缓存和数据库的一致性

12. **Redis集群模式**

    - 主从复制:简单的主从同步模型，主节点同步从节点，从节点也可以同步给其他的从节点
    - 哨兵模式：采用哨兵进行主节点状态监控，发现主节点故障可以发起选举
    - 集群：多个Redis节点组成集群，数据采用分片的方式分配，有节点宕机，则该节点上的分片要根据备份进行迁移，可以通过hash取模和hash槽(16384)进行数据的分片

## 消息中间件

1. **Kafka**

   - 十万级吞吐量，仅仅提供较少的功能保障超高的吞吐量，尽量使用少量的topic获取最大吞吐，是处理大数据和日志的好手,延迟也是ms级别
   - kafka采用发布订阅模型,相对于RocketMq来说，队列换成了partition
   - **如何保证kafka的消息有序性**，kafka只能保证Partitiion(分区)中的消息有序，不能保障多个分区间的顺序，所以可以采取两种方案
     - 一个key只对应一个Partition
     - (推荐)发送消息的时候执行 key%Partition
   - **如何保障kafka消息不丢失**
     - 生产者处丢失消息(send是异步的，需要调用get()方法获取发送结果)
     - 消费者处丢失消息(关闭offset自动提交，改为手动提交)
     - kafka内部丢失消息 acks=all,确保leader接受消息后，所有副本都同步成功了才认为消息发送成功

2. **RocketMq**

   - 基于AMQP协议实现的，十万级吞吐量，Java编写方便定制开发
   - RocketMq是基于topic模型实现的,**分为生产者组**，**消费者组**，**topic**(包含多个queue提高并发量，为每一个消费的消费者提供一个offset),对于消费者组的个数建议要大于topic中队列数，便于提高并发量
   - 通过offset可以防止重复消费，每次消费后offset+1，同一个队列中的消息可以被多个消费者组进行消费，只需各自维护各自的offset
   - **技术架构四大角色**：
     - **Broker**: 负责消息的存储，投递，查询，作为消息队列的服务器存在，Topic和Broker是多对多的关系，为了进行topic的备份，一个topic通常会放在多个Broker上，而一个Broker也会被分配多个Topic
     - **NameServer**: 作为注册中心，管理者Broker的信息，生产者和消费者通过他获取broker信息
     - **Producer**:  消息发布者，支持分布式集群方式部署
     - **Consumer**: 消息消费的角色，也支持分布式集群方案部署，支持以push推，pull拉

3. **RabbitMq**

   - 基于erlang开发，并发能力很强，延迟能达到微秒级别
   - **生产者**，**消费者**，**Exchange(交换器)**，**Queue(队列)**，**Broker**(消息中间件的服务节点)，**BindingKey(队列与Exchange绑定)**，**RoutingKey(路由键)**，Rabbit中的消息只能存储在队列中，这一点与Kafka不同，Kafka是将消息保存在Topic(主题)这一层面
     - **fanout(广播模式)**：会把所有发送到Exchange的消息广播到所有绑定在该交换器上的所有队列
     - **direct(直连模式)**：会把消息路由到那些BindingKey与RoutingKey完全匹配的队列中
     - **Topic(主题模式)**：因为direct的匹配规则不能满足所有场景，所有topic模式采用了模糊匹配的机制，只要符合匹配规则的队列都可以收到消息
     - **Headers(不推荐)**：根据消息的headrs(也是一个键值对的形式)对比其中的键与交换器绑定的键值对进行匹配，完全匹配将消息路由到该队列，该模式性能较差，几乎没人使用

4. **ActiveMq**

   - 基于JMS协议实现的，社区较为成熟，但性能较差，版本迭代较慢，万级吞吐量

5. **为什么使用消息中间件？**

   - 削峰，解耦，异步

6. **消息中间件技术选型**

   - 数据量级不大，追求响应速度，首选RabbitMq
   - 有大数据以及日志采集需求，必选Kafka
   - 大数据量环境，想自己做一些定制化开发可以采用RocketMq
   - Active和RabbitMq都是基于主从模式实现的高可用，而Kafka和RocketMq均采用分布式实现，一个数据多个副本模式，不会导致不可用

7. **如何保障消息队列的高可用**

   - 采用集群的方式进行高可用的部署，从高可用的角度来说kafka和rocketMq这块要出色的多，kafka可以把partition分配到多个broker上，并且一个partition会有多个副本，如果有broker宕机也没什么影响，如果是分区的lead所在broker宕机，则其余的follower会重新进行选举

     

## JVM调优

1. jvm内存布局，JMM内存模型
2. 什么是内存溢出?内存泄露？如何排查？
3. 方法区(元空间)存储什么？
   - 类的实例信息，静态变量，常量
4. JVM类加载过程？双亲委派模型？为什么要双亲委派
5. 垃圾收集器
   - 串行垃圾收集器
   - 并行垃圾收集器
   - CMS垃圾收集器
   - G1垃圾收集器
   - ZGC
6. 三色标记法
7. JVM的垃圾回收算法

## 分布式，微服务

### 分布式事务

- 两阶段提交协议

  有一个协调者的概念，假如：服务A，服务B

  - 预提交(协调者分别给多个服务发送预提交请求，此时服务执行事务，并不提交)
  - 提交(预提交全部做完，发送提交请求，服务提交事务释放资源，反馈给事务协调者)
  - 执行事务时有一个失败的活规定时间内没有反馈（此时事务协调者让参与事务的所有服务全部回滚）
  - 缺点：单点故障(协调者挂了，事务会失败)

- 三阶段提交协议
- TCC
- LCB

### Dubbo

1. **dubbo负载均衡策略**
   - 权重随机RabdomLoadBalance(默认，可设置权重)
   - 权重轮训(有序调用)RoundRobinLoadBalance,可以通过配置权重的方式均衡那些性能稍差的机器
   - 最小活跃负载均衡LeastActiveLoadBalance,根据服务器性能动态调整，请求进来active+1，处理完请求active-1，值越小调用的几率越大
   - 一致性Hash算法ConsistentHashLoadBalance，相同的参数的请求会被分配到同一机器上
2. **dubbo集群容错策略**
   - Failover Cluster模式(默认)：失败自动切换默认重试其他机器，默认重试次数2
   - Fail fast Cluster模式：一次调用失败立即失败
   - Failback Cluster模式：失败了后台自动记录请求，然后自动重发
   - Forking Cluster模式：并行调用多个provider，只要一个成功就返回
   - Broadcast cluster模式：逐个调用所有的provider，任何一个出错即报错
3. **dubbo动态代理策略**
   - 默认使用javassit动态字节码生成

### SpringBoot

1. SpringBoot是什么？spring自动装配创建代理类，可以工作spi机制配置自己的动态代理

### SpringCloud技术栈

1. 服务注册？熔断？负载均衡？微服务网关？消息总线？配置中心？

## 源码部分

### Spring源码

1. **Spring常用注解**
   - @Profile 表示哪些环境下应用该bean
   - @RestControllerAdvice 统一处理异常
   - @ConfigurationProperties    指定前缀加载配置文件
   - @PostConstruct  容器初始化执行该方法
2. **PostConstruct，ApplicationContextAware,InitializingBean执行顺序**
   - 2 1 3 
3. **AOP** 
   - 基于动态代理实现，如果使用接口则用jdk的动态代理实现，如果没有实现接口则用CGLIB来实现
4. **bean加载过程**
5. **如何解决循环依赖**

### Mybatis源码

- Mybatis启动过程

### Java基础

- **HashMap源码**
  - **put操作**
    1.  如果tab为null，调用resize进行初始化工作
    2. 通过hash找到下标，如果该位置的元素为空，则直接将数据存放进
    3. 如果当前下标元素不为null，那么此时有三种情况
       - 覆盖原值: 此时老key和新key的hashCode相同 && （equals相同或者两个key的引用相同），返回该元素
       - 添加到红黑树，遍历红黑树进行查找，如果发现有相同元素，返回该元素，否则插入红黑树
       - 添加到链表（尾部）:遍历链表,如果遍历的过程中有相同的元素(hash(key))相同，返回该位置的元素
    4. 如果以上三步有返回值的话，更新该Node的value值
    5. 如果此时的容量达到了阈值，那么进行扩容操作
  - **resize()：**
    1. 初始化一个Node<K,V>[],如果table==null有指定初始容量，把新创建的数组赋值给table，并重新计算阈值
    2. table不为空，创建一个新的数组，然后将原数组的元素重新hash迁移到新的数组
- **TreeSet和HashSet**
  - TreeSet是有序的，添加的元素也应该是有序的，或者实现了compareAble接口
  - HashSet底层是基于HashMap实现的，Put的时候value是一个假值，new Object()
- **跳表**
  - 基于调表的方式可以实现链表的二分查找，解决了链表查询效率的问题
  - 每两个或多个节点形成一个索引节点，依次向上形成一个数据结构
- **线程池源码**
- JUC包
- JDK动态代理，CGLIb动态代理
- **线程的生命周期**
  - 新建，就绪，运行，阻塞
- **如何停止线程**
  - run()或者call()方法执行完成，线程正常结束
  - 线程抛出一个未捕获的Exception活Error
  - 直接调用线程的stop方法来结束该线程-通常不推荐使用
- **synchronized锁升级过程**
  - javaSE 1.6 为了减少锁申请和释放锁带来的性能消耗而引入的偏向锁和轻量级锁
  - 锁升级顺序 无锁 --> 偏向锁 -->轻量级锁 -->重量级锁
  - **偏向锁**：当线程1访问该资源时，会在对象头的（Mark word）做一个锁标记，并记录自己的线程ID，执行完同步代码块后并不会主动释放锁，当第二次执行同步代码快时就不需要重复获取锁了，偏向锁会等到竞争出现的时候才会进行撤销，此时线程2开始访问同步代码块，首先会看到对象头的锁标识不是自己，会暂停当前持有锁的线程,并等到全局安全点，此时判断线程1是否存活，如果存活并且要竞争当前锁则升级为轻量级锁，否则将偏向锁撤销，线程2获得偏向锁
  - **轻量级锁**：轻量级所是指偏向锁时又被另一个线程访问，此时偏向锁就会升级为轻量级锁，采用自旋的方式获取锁
  - **重量级锁：** 由于长时间的自旋会导致CPU空转，耗费资源，此时当自旋的线程超过一定次数（默认是十次），会将锁升级为重量级锁，此时竞争锁的线程会处于阻塞状态，等待被唤醒。
-  **Comparator和Comparable区别**
  - Comparable自然排序实体类通过实现接口来拥有被排序的能力，Comparator是定制排序，定制排序的规则，无法修改实体类时可以采用


### 其他

1. 线上遇到cpu飙升，内存泄露问题如何定义解决 

   - c**pu飙升如何解决**
     1. 首先通过top命令查询到占用cpu最高的进程
     2. 然后根据top -Hp <pid>查询进程中线程占用cpu的情况
     3. jstack支持的pid是16进制格式，需要进行转化，printf "%x\n" 10
     4. 通过jstack能排查出线程的堆栈信息，如果发现有VM_THREAD的话就说明很有可能是fullGC，否则通过堆栈分析可以查阅到CPU高的原因
   - **Full GC**：
     1. 可以dump出内存日志，然后通过visualVm或者mat对日志进行分析
     2. visualVm在连接的时候比较耗费性能，尽量不要直连线上服务器
     3.  jstat -gcutil <pid> <period> <times> 可以通过jstat查询GC情况以及内存使用情况
     4. Jmap -heap <pid>  查看当前堆内存空间使用情况(百分比)，也可以使用jmap dump出内存信息，然后进行分析
   - **Arthas**:
     - dashboard  可以查询CPU占用情况，那些线程占用的高
     - 通过Thread <Tid>即可查询出线程的那部分代码导致的内存过高
     - jad可以反编译字节码，查看线上代码

2. **服务响应缓慢如何排查解决**

   - 网络带宽不够
   - 第三方响应时间过长
   - 服务器端线程池数量不够，导致请求排队等待(tomcat连接数不够用，导致连接hang住)
   - Full GC问题
   - 服务端压力过大，确实处理不过来了(单机吞吐有限，此种情况只能加机器)
   - 代码问题，使用了不当的同步锁

3. 如何能够让系统支撑千万级并发

4. 服务如何实现扩容缩容问题

5. 高并发情况下如何保证接口安全性

6. **hashMap为何线程不安全，如何导致死锁的**

   - 在多线程环境下扩容会导致死循环，CPU100%

7. **线程安全的list锁力度小一点的**

   -  Collections.synchronizedList 

8. **什么是泛型？泛型的作用**

   - 泛型意味着编写的代码可以被不同类型的对象所重用，可见泛型的作用是可以编写出重用性更好的代码。
   - 因为泛型擦除的存在，通过反射可以把任意类型的数据进行插入，比如ArrayList<Integer>可以插入String类型的数据，而底层有是用Object进行存储的，所以在取数据时类型转换可能会报错。

9. **什么是反射？反射有什么作用？**

   - 反射允许运行时的程序可以操作对象的内部属性，以及动态创建对象
   - 允许程序运行时根据类名动态的加载对象，也可以结合自定义注解做一些通用的配置

10. 什么是反射，反射有什么作用

11. **设计模式六大原则**

    - **单一职责原则**
    - **开闭原则**
    - **里氏替换原则** ：子类可以扩展父类的功能但不能改变父类原有的功能
    - **依赖导致原则**
    - **接口隔离原则**：一个类对另一个类的依赖应该建立在最小的接口上，即尽可能的避免实现哪些不需要的接口，把需要的单独抽象出来
    - **迪米特法则**(最少知道原则)：尽量降低类与类之间的偶尔

12. **select ,poll和epoll**

13. **ThreadLocal 原理，内存泄露问题**

    - ThreadLocal不是为了解决多线程共享变量的问题，而是为每个变量创建了一个副本
    - 每个线程都存在一个map，map的类型是ThreadLocal.ThreadLocalMap,map的key为一个threadlocal实例
    - **InheritableThreadLocal**:可以在线程间传递ThreadLocal变量
    - 产生内存泄露原因，

14. **强软弱虚引用**

      可以让程序员通过代码的方式管理对象的生命周期，有利于垃圾回收

    - **强引用**，大多数创建的对象都是强引用，JVM即使内存溢出了也不会去回收
    - **软引用**，SoftRefrence包裹的对象，内存不足时会被回收掉
    - **弱引用**，WeekReference只要是发生GC了就会被回收
    - **虚引用**，PhantomReference,虚引用必须与ReferenceQueue一起使用，当GC准备回收一个对象，会在回收之前把该对象放入与之关联的ReferenceQueue中，在NIO中，一般用来管理推外内存的

15. **什么是零拷贝技术**

    - **没有零拷贝之前**

      1. 数据文件拷贝到kernel模式中
      2. 由kernel模式复制到user模式下
      3. 有user模式下复制回kernel模式
      4. 最后有kernel模式复制到网卡设备中

    - **零拷贝**

        省略掉了kernel->user->kernel的过程，减少了两次文件拷贝

16. **海量数据排序问题** 

    - 分治法实现，把数据分区，依次加载每个分区的数据到内存进行排序
    - 所有的分区都排序完成后，再把分区进行拆分，一次性把分区的部分数据加载到内存进行排序，排序号的数据写入文件中，最终文件中的数据即为已排好的数据

17. **线程交替输出问题**

    - LockSupport  park()当前线程阻塞  unpark(Thread thread) 唤醒指定线程

    - wait notify  锁对象.wait() 持有当前对象锁的线程阻塞 lockObject.notify() 任意唤醒队列中的一个线程，如何保证谁先执行呢？CountdownLatch

    - TransferQueue 阻塞队列，队列里面数据为1，需要生产者和消费者完成'握手'过程，否则二者都会阻塞

      

      

      

      

      

      dubbo调用过程

      rabbitMq持久化机制
      
      springBoot启动流程









